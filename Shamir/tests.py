from main import *
import sympy.ntheory as nt
import random



""" 
Expected result is generated by https://www.extendedeuclideanalgorithm.com/calculator.php
"""
def test_extended_euclid_gcd():
    inputs = [(10,5), (15, 8), (41, 13), (100, 10), (100, 3), (100, 1), (1203, 123)]
    expected = [(5,0,1), (1,-1,2),(1,-6,19),(10,0,1),(1,1,-33),(1,0,1),(3,9,-88)]
    for i in range(len(inputs)):
        a, b = inputs[i]
        d, x, y = extended_euclid_gcd(a, b)
        assert (d, x, y) == expected[i]



def test_all():
    secret = [1234]
    numOfShares = 6
    threshold = 3
    fieldsize = 1613

    shares = split_secrets(secret, numOfShares, threshold,fieldsize)

    reconstructedSecret1 = reconstruct_secrets(shares[:threshold], 1, fieldsize)
    reconstructedSecret2 = reconstruct_secrets(shares[-threshold:], 1, fieldsize)
    
    assert secret == reconstructedSecret1 == reconstructedSecret2 

def test_with_different_primes():
    # Generate a list of primes
    startingPrime = 1619
    primes = [startingPrime]
    nums = [2**i for i in range(12,100)]
    for i in range(len(nums)):
        workingPrime = nt.nextprime(nums[i] )
        primes.append(workingPrime)

    for i in range(len(primes)):
        workingPrime = primes[i]
        secret = [1234]
        numOfShares = 6
        threshold = 3

        shares = split_secrets(secret, numOfShares, threshold, workingPrime)

        reconstructedSecret1 = reconstruct_secrets(shares[:threshold], 1, workingPrime)
        reconstructedSecret2 = reconstruct_secrets(shares[-threshold:], 1, workingPrime)

        assert secret == reconstructedSecret1 == reconstructedSecret2 


def test_one_lies():
    secret = [1234]
    numOfShares = 6
    threshold = 3
    fieldsize = 1613

    shares = split_secrets(secret, numOfShares, threshold,fieldsize)

    # One share lies 
    shares[0] = (shares[0][0], shares[0][1] - 1)

    reconstructedSecret1 = reconstruct_secrets(shares[:threshold], 1, fieldsize)
    reconstructedSecret2 = reconstruct_secrets(shares[-threshold:], 1, fieldsize)
    assert secret != reconstructedSecret1
    assert secret == reconstructedSecret2

def test_detect_errors():
    secret = [1234]
    numOfShares = 6
    threshold = 3
    fieldsize = 1613

    shares = split_secrets(secret, numOfShares, threshold,fieldsize)

    # One share lies 
    shares[5] = (shares[5][0], shares[5][1] - 1)

    checkPointError = shares[5]
    checkPointHonest = shares[4]
    # First 3 shares (are honest)
    data = shares[:threshold]

    # All shares are honest and the checkpoint is lying
    foundErrors = detect_error(data, checkPointError, fieldsize)

    # All shares are honest and so is the checkpoint
    foundErrors1 = detect_error(data, checkPointHonest, fieldsize)

    assert foundErrors == True
    assert foundErrors1 == False

def additive_test():
    secret1 = [1]
    secret2 = [1]
    secret3 = [0]
    threshold = 2
    numOfShares = 3
    fieldsize = 1613

    #Contruct the shares for each secret
    shares1 = split_secrets(secret1, numOfShares, threshold, fieldsize)
    shares2 = split_secrets(secret2, numOfShares, threshold, fieldsize)
    shares3 = split_secrets(secret3, numOfShares, threshold, fieldsize)

    #Add the shares together
    shares = []
    for i in range(3):
        shares.append((shares1[i][0], (shares1[i][1] + shares2[i][1] + shares3[i][1]) % fieldsize))

    #Reconstruct the secret
    reconstructedSecret = reconstruct_secrets(shares, 1, fieldsize)
    assert reconstructedSecret == [2]

    #Recontruct the secret with only 2 shares from each secret
    reconstructedSecret = reconstruct_secrets(shares[:2], 1, fieldsize)
    assert reconstructedSecret == [2]
    

"""
To reconstruct we must use (numOfSecrets + threshold-1) shares
"""
def test_multiple_secrets():
    secrets = [2,3,4,6,7]
    threshold = 4
    numOfShares = 16
    fieldsize = 1613
    sharedNeeded = len(secrets) + threshold - 1

    shares = split_secrets(secrets, numOfShares, threshold, fieldsize)
    #Reconstruct the secrets
    reconstructedSecret = reconstruct_secrets(shares[:sharedNeeded], len(secrets), fieldsize)
    assert reconstructedSecret == secrets

def berlekamp_welsh_example():

    def normalize(poly):
        while poly and poly[-1] == 0:
            poly.pop()
        if poly == []:
            poly.append(0)

    def poly_divmod(num, den, fieldsize):
        #Create normalized copies of the args
        num = num[:]
        den = den[:]
        normalize(num)
        normalize(den)

        print(f"num before normalizing: {num}")
        print(f"den before normalizing: {den}")

        if len(num) >= len(den):
            #Shift den towards right so it's the same degree as num
            shiftlen = len(num) - len(den)
            den = [0] * shiftlen + den
        else:
            return [0], num


        print(f"num after normalizing: {num}")
        print(f"den after normalizing: {den}")

        den = den[::-1]
        print(f"den after reversing: {den}")

        quot = []
        divisor = int(den[-1])
        for i in range(shiftlen + 1):
            #Get the next coefficient of the quotient.
            mult = div_mod(num[-1], divisor, fieldsize)
            quot = [mult] + quot

            #Subtract mult * den from num, but don't bother if mult == 0
            #Note that when i==0, mult!=0; so quot is automatically normalized.
            if mult != 0:
                d = [(mult * u) % fieldsize for u in den]
                num = [(u - v) % fieldsize for u, v in zip(num, d)]

            num.pop()
            den.pop(0)

        normalize(num)
        return quot, num


    def berlekamp_welsh(shares, maxNumOfErrors, finalDegree, fieldsize):
        import sympy as sp

        def mPrint(matrix, msg):
            print(f"{msg}:")
            n,m = matrix.shape
            for i in range(n):
                print(f"row {i}: {matrix.row(i)}")
            print("\n")

        k = maxNumOfErrors # 2
        n = finalDegree # 5
        nkm1 = n + k - 1 # 6
        n2km1 = n + 2*k - 1 # 8
        n2k = n + 2*k # 9
        nk = n + k # 7
        xp, yp = zip(*shares)

        # A matrix of size n2k x nk (rows x columns)
        A = sp.zeros(n2k, nk)
        for i in range(n2k):
            for j in range(nk):
                A[i,j] = (i+1)**j

        mPrint(A, "Coefficient matrix A")
        
        # b Matrix of size n2k x k+1 (rows x columns)
        b = sp.zeros(n2k, k+1)
        for i in range(n2k):
            for j in range(k+1):
                b[i,j] = (i+1)**j
            # Multiply yp[i] onto the i'th row
            b[i,:] = b[i,:] * yp[i]

        mPrint(b, "b")

        # Move the b matrix to the right hand side of the equation except for the last column
        A = (-b[:,:-1]).row_join(A)
        mPrint(A, "A after joining b")

        # Delete everything but the last column of b
        b = b[:,-1]

        ans = None
        det = int(A.det())
        gcd, _, _ = extended_euclid_gcd(det, fieldsize)
        if gcd == 1:
            ans = pow(det, -1, fieldsize) * A.adjugate() @ b % fieldsize
            print(ans)
        else:
            print("don't know")

        # get first k elements of ans
        aValues = ans[k:]
        bValues = ans[:k]
        bValues.insert(0,1)

        print(f"aValues: {aValues}")
        print(f"bValues: {bValues}")
        print(f"len(aValues): {len(aValues)}")
        print(f"len(bValues): {len(bValues)}")

        # Error locator polynomial. E(x) = bValues[0] + bValues[1]x + ... + bValues[k-1]x^(k-1) + x^k
        # Q ploy. Q(x) = aValues[0] + aValues[1]x + ... + aValues[n+k-1]x^(n+k-1)
        # P(x) = Q(x) / E(x)

        p, q = poly_divmod(aValues, bValues, fieldsize)
        print(f"p: {p}")
        print(f"q: {q}")
        print(f"xp: {xp}")
        
        sec = reconstruct_secrets(zip(xp,p),1,fieldsize)

        print(f"Secret: {sec}")

        return 0

    secret = [1234]

    k = 2
    threshold = 5
    numOfShares = threshold + 2*k
    fieldsize = 1613

    shares = split_secrets(secret, numOfShares, threshold, fieldsize)
    shares = [(6, 103), (7, 753), (8, 1583), (9, 716), (10, 1045), (11, 555), (12, 388), (13, 4), (14, 407)] # Forcing the shares to be the same in testing
    print(f"Shares: \t \t {shares}")

    # the last two shares are lying
    shares = shares[:-2] + [(shares[-2][0], shares[-2][1] - 1), (shares[-1][0], shares[-1][1] - 1)]
    print(f"Shares after lying: \t {shares}")

    polyPoints = berlekamp_welsh(shares, k, threshold, fieldsize)



if __name__ == "__main__":
    #test_extended_euclid_gcd()
    #test_all()
    #test_one_lies()
    #test_detect_errors()
    #test_with_different_primes()
    #additive_test()
    #test_multiple_secrets()
    berlekamp_welsh_example()
    print("Everything passed: üëç")